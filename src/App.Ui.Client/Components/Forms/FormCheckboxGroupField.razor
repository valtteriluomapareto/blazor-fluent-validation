@using System.Globalization
@using System.Linq.Expressions
@using Microsoft.AspNetCore.Components.Forms
@typeparam TOption

<FormField TValue="List<TOption>" Id="@ResolvedId" Label="@Label" HelpText="@HelpText" ValueExpression="ValueExpression">
    <div class="space-y-2">
        @for (var index = 0; index < Options.Count; index++)
        {
            var option = Options[index];
            var optionId = GetOptionId(index);
            var optionValue = GetOptionValue(option.Value);
            var isChecked = IsSelected(option.Value);

            <label class="flex cursor-pointer items-start gap-2 rounded-md border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 hover:border-slate-300" for="@optionId">
                <input
                    id="@optionId"
                    data-option-value="@optionValue"
                    class="mt-0.5 h-4 w-4 rounded border-slate-300 text-slate-900 focus:ring-slate-300"
                    type="checkbox"
                    checked="@isChecked"
                    @onchange="@(args => OnChangedAsync(option.Value, args))" />
                <span class="space-y-0.5">
                    <span class="block font-medium text-slate-800">@option.Label</span>
                    @if (!string.IsNullOrWhiteSpace(option.HelpText))
                    {
                        <span class="block text-xs text-slate-500">@option.HelpText</span>
                    }
                </span>
            </label>
        }

        @if (OtherOption is not null)
        {
            var otherOptionIndex = Options.Count;
            var otherOptionId = GetOptionId(otherOptionIndex);
            var otherOptionValue = GetOptionValue(OtherOption.Value);
            var otherSelected = IsSelected(OtherOption.Value);

            @* 
               "Other" is rendered as a first-class checkbox option, but it also
               conditionally reveals a text input. The text input is bound via
               @bind-OtherValue (OtherValue/OtherValueChanged) so parent models
               can capture the free-form value separately from the enum/list selection.
            *@
            <div class="space-y-2">
                <label class="flex cursor-pointer items-start gap-2 rounded-md border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 hover:border-slate-300" for="@otherOptionId">
                    <input
                        id="@otherOptionId"
                        data-option-value="@otherOptionValue"
                        class="mt-0.5 h-4 w-4 rounded border-slate-300 text-slate-900 focus:ring-slate-300"
                        type="checkbox"
                        checked="@otherSelected"
                        @onchange="@(args => OnChangedAsync(OtherOption.Value, args))" />
                    <span class="space-y-0.5">
                        <span class="block font-medium text-slate-800">@OtherOption.Label</span>
                        @if (!string.IsNullOrWhiteSpace(OtherOption.HelpText))
                        {
                            <span class="block text-xs text-slate-500">@OtherOption.HelpText</span>
                        }
                    </span>
                </label>

                @if (otherSelected)
                {
                    @* 
                       We only show the free-form input when "Other" is selected.
                       This keeps the UI uncluttered and matches how validation rules
                       typically require the text only when the option is chosen.
                    *@
                    <div class="pl-6">
                        <input
                            id="@OtherInputId"
                            class="mt-1 w-full rounded-md border border-slate-300 px-3 py-2 text-sm text-slate-900 focus:border-slate-400 focus:outline-none focus:ring-2 focus:ring-slate-200"
                            type="text"
                            placeholder="@OtherPlaceholder"
                            value="@OtherValue"
                            @oninput="OnOtherValueChangedAsync" />

                        @if (OtherValueExpression is not null)
                        {
                            <ValidationMessage For="OtherValueExpression" class="mt-1 text-sm text-rose-600" />
                        }
                    </div>
                }
            </div>
        }
    </div>
</FormField>

@code {
    [CascadingParameter] private EditContext? EditContext { get; set; }

    [Parameter] public string Id { get; set; } = string.Empty;
    [Parameter] public string Label { get; set; } = string.Empty;
    [Parameter] public string? HelpText { get; set; }
    [Parameter] public List<TOption> Value { get; set; } = [];
    [Parameter] public EventCallback<List<TOption>> ValueChanged { get; set; }
    [Parameter] public Expression<Func<List<TOption>>>? ValueExpression { get; set; }
    [Parameter] public IReadOnlyList<ChoiceOption<TOption>> Options { get; set; } = [];
    [Parameter] public ChoiceOption<TOption>? OtherOption { get; set; }
    [Parameter] public string? OtherValue { get; set; }
    [Parameter] public EventCallback<string?> OtherValueChanged { get; set; }
    [Parameter] public Expression<Func<string?>>? OtherValueExpression { get; set; }
    [Parameter] public string? OtherPlaceholder { get; set; }
    [Parameter] public bool ClearOtherOnDeselect { get; set; } = true;

    // FieldIdentifier lets us manually notify the EditContext that a value changed.
    // This is important because the component manages state internally and doesn't
    // always use the built-in InputBase pipeline for every interaction.
    private FieldIdentifier? fieldIdentifier;
    private FieldIdentifier? otherFieldIdentifier;
    private readonly string componentId = Guid.NewGuid().ToString("N")[..8];

    private string ResolvedId => FormFieldIdResolver.Resolve(Id, ValueExpression, componentId, "group");

    protected override void OnParametersSet()
    {
        // Cache the identifiers so we can call EditContext.NotifyFieldChanged(...)
        // after we update Value/OtherValue. This keeps validation messages in sync.
        if (EditContext is not null && ValueExpression is not null)
        {
            fieldIdentifier = FieldIdentifier.Create(ValueExpression);
        }

        if (EditContext is not null && OtherValueExpression is not null)
        {
            otherFieldIdentifier = FieldIdentifier.Create(OtherValueExpression);
        }
    }

    private bool IsSelected(TOption option)
    {
        // Use the default equality comparer so this works for enums, records,
        // and other value types without requiring custom comparison logic.
        var comparer = EqualityComparer<TOption>.Default;
        return Value.Any(value => comparer.Equals(value, option));
    }

    private async Task OnChangedAsync(TOption option, ChangeEventArgs args)
    {
        var isChecked = args.Value is bool b && b;
        var comparer = EqualityComparer<TOption>.Default;
        var next = new List<TOption>(Value);
        var isOtherOption = IsOtherOption(option);

        if (isChecked)
        {
            if (!next.Any(value => comparer.Equals(value, option)))
            {
                next.Add(option);
            }
        }
        else
        {
            next.RemoveAll(value => comparer.Equals(value, option));
        }

        Value = next;
        await ValueChanged.InvokeAsync(next);
        NotifyFieldChanged(fieldIdentifier);

        // If the user deselects "Other", we can optionally clear its text value.
        // Clearing prevents stale "Other" text from being submitted later.
        if (
            !isChecked
            && isOtherOption
        )
        {
            if (ClearOtherOnDeselect && !string.IsNullOrWhiteSpace(OtherValue))
            {
                OtherValue = string.Empty;
                await OtherValueChanged.InvokeAsync(OtherValue);
            }

            // Always notify the "Other" field when it is deselected so
            // conditional validation messages can clear correctly.
            NotifyFieldChanged(otherFieldIdentifier);
        }
    }

    private string OtherInputId => $"{ResolvedId}-other-value";

    private string GetOptionId(int index) => $"{ResolvedId}-opt-{index}";

    private static string GetOptionValue(TOption value) =>
        Convert.ToString(value, CultureInfo.InvariantCulture) ?? string.Empty;

    private bool IsOtherOption(TOption option)
    {
        // Treat "Other" as just another option value, but guard for null.
        return OtherOption is not null
            && EqualityComparer<TOption>.Default.Equals(option, OtherOption.Value);
    }

    private async Task OnOtherValueChangedAsync(ChangeEventArgs args)
    {
        var nextOtherValue = args.Value?.ToString() ?? string.Empty;
        if (string.Equals(OtherValue, nextOtherValue, StringComparison.Ordinal))
        {
            return;
        }

        // Update the free-form value and notify both the parent and EditContext
        // so any validators watching the "Other" text run immediately.
        OtherValue = nextOtherValue;
        await OtherValueChanged.InvokeAsync(nextOtherValue);
        NotifyFieldChanged(otherFieldIdentifier);
    }

    private void NotifyFieldChanged(FieldIdentifier? identifier)
    {
        // The identifier may be absent in unit tests or if ValueExpression is not provided.
        if (EditContext is not null && identifier.HasValue)
        {
            EditContext.NotifyFieldChanged(identifier.Value);
        }
    }
}
