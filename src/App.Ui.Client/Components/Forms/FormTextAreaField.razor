@using System.Linq.Expressions

<FormField TValue="string" Id="@ResolvedId" Label="@Label" HelpText="@HelpText" ValueExpression="ValueExpression">
    <InputTextArea
        id="@ResolvedId"
        class="w-full rounded-md border border-slate-300 bg-white px-3 py-2 text-sm shadow-sm focus:border-slate-400 focus:outline-none focus:ring-2 focus:ring-slate-200"
        rows="@Rows"
        @bind-Value="CurrentValue"
        @bind-Value:event="@(UpdateOnInput ? "oninput" : "onchange")"
        @onfocus="HandleFocus"
        @onfocusout="HandleBlur"
        @attributes="MergedInputAttributes" />
</FormField>

@code {
    [CascadingParameter] private EditContext? EditContext { get; set; }

    [Parameter] public string Id { get; set; } = string.Empty;
    [Parameter] public string Label { get; set; } = string.Empty;
    [Parameter] public string? HelpText { get; set; }
    [Parameter] public string Value { get; set; } = string.Empty;
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public Expression<Func<string>>? ValueExpression { get; set; }
    [Parameter] public string? Placeholder { get; set; }
    [Parameter] public int Rows { get; set; } = 4;
    [Parameter] public bool UpdateOnInput { get; set; }
    [Parameter] public bool ValidateOnBlur { get; set; }
    [Parameter] public Dictionary<string, object>? InputAttributes { get; set; }

    private readonly string _componentId = Guid.NewGuid().ToString("N")[..8];
    private bool _touched;
    private string? _valueOnFocus;

    private string ResolvedId => FormFieldIdResolver.Resolve(Id, ValueExpression, _componentId);

    private string CurrentValue
    {
        get => Value;
        set
        {
            if (string.Equals(Value, value, StringComparison.Ordinal))
            {
                return;
            }

            Value = value;
            _ = ValueChanged.InvokeAsync(value);

            // Notify EditContext with the correct field identifier.
            // InputTextArea's internal binding notifies about "CurrentValue", not the model property,
            // so we need to explicitly notify about the actual model field for validation to work.
            if (EditContext is not null && ValueExpression is not null)
            {
                EditContext.NotifyFieldChanged(FieldIdentifier.Create(ValueExpression));
            }
        }
    }

    private void HandleFocus()
    {
        _touched = true;
        _valueOnFocus = Value;
    }

    private void HandleBlur()
    {
        if (!ValidateOnBlur || !_touched || EditContext is null || ValueExpression is null)
        {
            return;
        }

        // Only trigger validation on blur if value didn't change since focus.
        // If value changed, validation already ran via EditContext.OnFieldChanged.
        if (string.Equals(Value, _valueOnFocus, StringComparison.Ordinal))
        {
            var fieldIdentifier = FieldIdentifier.Create(ValueExpression);
            EditContext.NotifyFieldChanged(fieldIdentifier);
        }
    }

    private IReadOnlyDictionary<string, object>? MergedInputAttributes
    {
        get
        {
            if (InputAttributes is null && string.IsNullOrWhiteSpace(Placeholder))
            {
                return null;
            }

            var attributes = InputAttributes is null
                ? new Dictionary<string, object>()
                : new Dictionary<string, object>(InputAttributes);

            if (!string.IsNullOrWhiteSpace(Placeholder))
            {
                attributes["placeholder"] = Placeholder;
            }

            return attributes;
        }
    }

}
