@using System.Globalization
@using System.Linq.Expressions
@using Microsoft.AspNetCore.Components.Forms
@typeparam TValue

<FormField TValue="TValue" Id="@ResolvedId" Label="@Label" HelpText="@HelpText" ValueExpression="ValueExpression">
    <InputRadioGroup TValue="TValue" Name="@GroupName" class="space-y-2" @bind-Value="CurrentValue">
        @for (var index = 0; index < Options.Count; index++)
        {
            var option = Options[index];
            var optionId = GetOptionId(index);
            <label class="flex cursor-pointer items-start gap-2 rounded-md border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 hover:border-slate-300" for="@optionId">
                <InputRadio
                    TValue="TValue"
                    Value="@option.Value"
                    AdditionalAttributes="GetOptionAttributes(optionId, option.Value)" />
                <span class="space-y-0.5">
                    <span class="block font-medium text-slate-800">@option.Label</span>
                    @if (!string.IsNullOrWhiteSpace(option.HelpText))
                    {
                        <span class="block text-xs text-slate-500">@option.HelpText</span>
                    }
                </span>
            </label>
        }

        @if (OtherOption is not null)
        {
            var otherOptionIndex = Options.Count;
            var otherOptionId = GetOptionId(otherOptionIndex);

            @*
              "Other" is treated as an additional radio option. When it is selected,
              we reveal a text input and bind it via @bind-OtherValue so the parent
              can capture the free-form value separately from the selected enum/value.
            *@
            <div class="space-y-2">
                <label class="flex cursor-pointer items-start gap-2 rounded-md border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700 hover:border-slate-300" for="@otherOptionId">
                    <InputRadio
                        TValue="TValue"
                        Value="@OtherOption.Value"
                        AdditionalAttributes="GetOptionAttributes(otherOptionId, OtherOption.Value)" />
                    <span class="space-y-0.5">
                        <span class="block font-medium text-slate-800">@OtherOption.Label</span>
                        @if (!string.IsNullOrWhiteSpace(OtherOption.HelpText))
                        {
                            <span class="block text-xs text-slate-500">@OtherOption.HelpText</span>
                        }
                    </span>
                </label>

                @if (IsOtherSelected)
                {
                    @*
                      Only render the free-form input when "Other" is the active value.
                      This mirrors common UX and prevents validators from running against
                      a field the user cannot see or interact with.
                    *@
                    <div class="pl-6">
                        <input
                            id="@OtherInputId"
                            class="mt-1 w-full rounded-md border border-slate-300 px-3 py-2 text-sm text-slate-900 focus:border-slate-400 focus:outline-none focus:ring-2 focus:ring-slate-200"
                            type="text"
                            placeholder="@OtherPlaceholder"
                            value="@OtherValue"
                            @oninput="OnOtherValueChangedAsync" />

                        @if (OtherValueExpression is not null)
                        {
                            <ValidationMessage For="OtherValueExpression" class="mt-1 text-sm text-rose-600" />
                        }
                    </div>
                }
            </div>
        }
    </InputRadioGroup>
</FormField>

@code {
    [CascadingParameter] private EditContext? EditContext { get; set; }

    [Parameter] public string Id { get; set; } = string.Empty;
    [Parameter] public string Label { get; set; } = string.Empty;
    [Parameter] public string? HelpText { get; set; }
    [Parameter] public TValue Value { get; set; } = default!;
    [Parameter] public EventCallback<TValue> ValueChanged { get; set; }
    [Parameter] public Expression<Func<TValue>>? ValueExpression { get; set; }
    [Parameter] public string? Name { get; set; }
    [Parameter] public IReadOnlyList<ChoiceOption<TValue>> Options { get; set; } = [];
    [Parameter] public ChoiceOption<TValue>? OtherOption { get; set; }
    [Parameter] public string? OtherValue { get; set; }
    [Parameter] public EventCallback<string?> OtherValueChanged { get; set; }
    [Parameter] public Expression<Func<string?>>? OtherValueExpression { get; set; }
    [Parameter] public string? OtherPlaceholder { get; set; }
    [Parameter] public bool ClearOtherOnDeselect { get; set; } = true;

    // We cache FieldIdentifier values so we can manually notify the EditContext
    // when the selected value or the "Other" text changes.
    private FieldIdentifier? fieldIdentifier;
    private FieldIdentifier? otherFieldIdentifier;
    private readonly string componentId = Guid.NewGuid().ToString("N")[..8];

    private string ResolvedId => FormFieldIdResolver.Resolve(Id, ValueExpression, componentId, "group");

    protected override void OnParametersSet()
    {
        // ValueExpression / OtherValueExpression may be omitted in tests,
        // so we guard each identifier creation.
        if (EditContext is not null && ValueExpression is not null)
        {
            fieldIdentifier = FieldIdentifier.Create(ValueExpression);
        }

        if (EditContext is not null && OtherValueExpression is not null)
        {
            otherFieldIdentifier = FieldIdentifier.Create(OtherValueExpression);
        }
    }

    private TValue CurrentValue
    {
        get => Value;
        set
        {
            // Avoid firing callbacks/validation when nothing actually changed.
            if (EqualityComparer<TValue>.Default.Equals(Value, value))
            {
                return;
            }

            var wasOtherSelected = IsOtherValue(Value);
            Value = value;
            _ = ValueChanged.InvokeAsync(value);
            NotifyFieldChanged(fieldIdentifier);

            // If the user moves away from "Other", optionally clear its text so
            // we do not carry a stale free-form value forward.
            if (wasOtherSelected && !IsOtherValue(value))
            {
                if (ClearOtherOnDeselect && !string.IsNullOrWhiteSpace(OtherValue))
                {
                    OtherValue = string.Empty;
                    _ = OtherValueChanged.InvokeAsync(OtherValue);
                }

                // Always notify the "Other" field when it becomes inactive so
                // conditional validation messages can clear correctly.
                NotifyFieldChanged(otherFieldIdentifier);
            }
        }
    }

    private string GroupName => string.IsNullOrWhiteSpace(Name) ? ResolvedId : Name;

    private bool IsOtherSelected =>
        OtherOption is not null && IsOtherValue(Value);

    private string OtherInputId => $"{ResolvedId}-other-value";

    private string GetOptionId(int index) => $"{ResolvedId}-opt-{index}";

    private static IReadOnlyDictionary<string, object> GetOptionAttributes(string optionId, TValue value)
    {
        var optionValue = Convert.ToString(value, CultureInfo.InvariantCulture) ?? string.Empty;
        return new Dictionary<string, object>
        {
            ["id"] = optionId,
            ["class"] = "mt-0.5",
            ["data-option-value"] = optionValue,
        };
    }

    private bool IsOtherValue(TValue value)
    {
        // Use the default comparer so this works for enums and other value types.
        return OtherOption is not null
            && EqualityComparer<TValue>.Default.Equals(value, OtherOption.Value);
    }

    private async Task OnOtherValueChangedAsync(ChangeEventArgs args)
    {
        var nextOtherValue = args.Value?.ToString() ?? string.Empty;
        if (string.Equals(OtherValue, nextOtherValue, StringComparison.Ordinal))
        {
            return;
        }

        // Keep parent state and validation in sync with every keystroke.
        OtherValue = nextOtherValue;
        await OtherValueChanged.InvokeAsync(nextOtherValue);
        NotifyFieldChanged(otherFieldIdentifier);
    }

    private void NotifyFieldChanged(FieldIdentifier? identifier)
    {
        // Identifier can be null when the component is used without expressions.
        if (EditContext is not null && identifier.HasValue)
        {
            EditContext.NotifyFieldChanged(identifier.Value);
        }
    }
}
